version(FileGenerator)
{
    import std.conv : to;
    import jaster.serialise.builder;
    
    const COLOUR_DATA_FILE      = "autogen/colours.txt";
    const COLOUR_D_PATH         = "../source/jarena/graphics/colours.d";
    const SCANCODE_DATA_FILE    = "autogen/scancode.txt";
    const SCANCODE_D_PATH       = "../source/jarena/graphics/scancode.d";

    void main()
    {
        import std.file : write;

        write(COLOUR_D_PATH,    genColourModule());
        write(SCANCODE_D_PATH,  genScancodeModule());
    }

    public string genScancodeModule()
    {
        auto code = new CodeBuilder();
        code.putf("// Generated on %s at %s with jarena:generator", __DATE__, __TIME__);
        code.put("// This file _would_ be included inside of window.d, but since it's autogenerated it's easier to put it in it's own file.");
        code.put("module jarena.graphics.scancode;");
        code.put("import derelict.sdl2.sdl;");

        code.put("enum Scancode : SDL_Scancode");
        code.putScope((_)
        {
            code.genScancodes();
        });

        return code.data.to!string;
    }
    
    public string genColourModule()
    {
        auto code = new CodeBuilder();
        code.putf("// Generated on %s at %s with jarena:generator", __DATE__, __TIME__);
        code.put("module jarena.graphics.colours;");
        code.put("public import arsd.colour;");

        code.put("abstract class Colours");
        code.putScope((_)
        {
            code.put("private static Colour[string] _colours;");
            code.genColours();
        });

        return code.data.to!string;
    }

    private immutable scancodeData = import(SCANCODE_DATA_FILE);
    private void genScancodes(CodeBuilder code)
    {
        import std.algorithm : splitter, map, substitute, joiner;
        import std.uni       : toLower, isNumber;
        import std.array     : array;
        import std.regex     : matchFirst, ctRegex;
        import std.format    : format;

        string fixName(string name)
        {
            return (name[0].isNumber) ? "NUM"~name
                                      : name;
        }

        auto exp      = ctRegex!`(SDL_SCANCODE_(\w+)).*`;
        auto enumCode = scancodeData.splitter("\n")
                                    .map!(line => line.matchFirst(exp))
                                    .map!(cap  => format("%s = %s", fixName(cap[2]), cap[1]))
                                    .joiner(",\n\t")
                                    .array;

        code.put(enumCode);
    }
    
    private immutable colourData = import(COLOUR_DATA_FILE);
    private void genColours(CodeBuilder code)
    {
        import std.algorithm : substitute, splitter, skipOver, startsWith;
        import std.range     : chain;
        import std.uni       : toLower;
        import std.array     : array;

        // Find where the colour data starts
        auto dataByLine = colourData.splitter("\r\n");
        dataByLine.skipOver!(l => !l.startsWith(`"Colour Name"`));
        dataByLine.popFront(); // Skip over the "Colour Name" line.

        auto coloursGetterCode = new CodeBuilder();
        coloursGetterCode.put("static Colour[string] colours(){if(_colours is null) _colours = [");

        code.put("public static @nogc @safe nothrow pure const{");
        foreach(line; dataByLine)
        {
            // Line format: "Renese [Name]"[tab]R[tab]G[tab]B
            // Make the colour's name:
            // "Renese Azure" -> "azure"
            // "Renese Aero Blue" -> "aeroBlue"

            auto lineData   = line.splitter("\t");
            string fakeName = lineData.popReturn().substitute("\"", "", "Resene ", "", "JArena ", "").array.to!string;
            ubyte r         = lineData.popReturn().to!ubyte;
            ubyte g         = lineData.popReturn().to!ubyte;
            ubyte b         = lineData.popReturn().to!ubyte;
            assert(lineData.empty);

            // Fixup the name
            char[] name;
            auto nameSplit = fakeName.splitter(" ");
            name ~= nameSplit.popReturn().toLower();
            foreach(nameComp; nameSplit)
                name ~= nameComp;
        
            code.putf("static Colour %s() { return Colour(%s, %s, %s, 255); }",
                      name, r, g, b);

            coloursGetterCode.putf("\"%s\": Colours.%s,", name, name);
        }

        code.put("}");
        coloursGetterCode.put("]; return _colours; }");
        code.put(coloursGetterCode.data);
    }

    private auto popReturn(R)(ref R range)
    {
        auto val = range.front;
        range.popFront();
        return val;
    }
}
